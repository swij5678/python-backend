name: Hotfix Deployment

on:
  push:
    branches:
      - 'hotfix/**'
  workflow_dispatch:
    inputs:
      hotfix_branch:
        description: 'Hotfix branch name'
        required: true
        type: string
      target_environment:
        description: 'Target environment for hotfix'
        required: true
        default: 'production'
        type: choice
        options:
          - staging
          - production
      skip_tests:
        description: 'Skip tests (emergency only)'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  validate-hotfix:
    name: Validate Hotfix
    runs-on: ubuntu-latest
    
    outputs:
      is-emergency: ${{ steps.check.outputs.is-emergency }}
      hotfix-version: ${{ steps.version.outputs.version }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Validate hotfix branch
      id: check
      run: |
        BRANCH_NAME=${GITHUB_REF#refs/heads/}
        if [[ "$BRANCH_NAME" =~ ^hotfix/ ]]; then
          echo "âœ… Valid hotfix branch: $BRANCH_NAME"
        else
          echo "âŒ Not a valid hotfix branch"
          exit 1
        fi
        
        # Check if this is an emergency hotfix
        if echo "$BRANCH_NAME" | grep -q "emergency"; then
          echo "âš ï¸ Emergency hotfix detected"
          echo "is-emergency=true" >> $GITHUB_OUTPUT
        else
          echo "is-emergency=false" >> $GITHUB_OUTPUT
        fi
        
    - name: Generate hotfix version
      id: version
      run: |
        # Get the latest tag and increment patch version
        LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
        VERSION=${LATEST_TAG#v}
        
        # Split version into parts
        IFS='.' read -r -a VERSION_PARTS <<< "$VERSION"
        MAJOR=${VERSION_PARTS[0]}
        MINOR=${VERSION_PARTS[1]}
        PATCH=${VERSION_PARTS[2]}
        
        # Increment patch version
        NEW_PATCH=$((PATCH + 1))
        NEW_VERSION="$MAJOR.$MINOR.$NEW_PATCH"
        
        echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
        echo "Generated hotfix version: $NEW_VERSION"

  emergency-approval:
    name: Emergency Approval
    runs-on: ubuntu-latest
    needs: validate-hotfix
    if: needs.validate-hotfix.outputs.is-emergency == 'true'
    environment:
      name: emergency-approval
      
    steps:
    - name: Request emergency approval
      run: |
        echo "ðŸš¨ Emergency hotfix requires approval"
        echo "Hotfix version: ${{ needs.validate-hotfix.outputs.hotfix-version }}"
        echo "Please review and approve this emergency deployment"

  quick-tests:
    name: Quick Test Suite
    runs-on: ubuntu-latest
    needs: validate-hotfix
    if: github.event.inputs.skip_tests != 'true'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -e .[dev]
        
    - name: Run critical tests only
      run: |
        # Run only critical/smoke tests for hotfixes
        pytest -v -m "not slow" --maxfail=1 tests/
        
    - name: Quick lint check
      run: |
        flake8 src --select=E9,F63,F7,F82 --show-source --statistics

  build-hotfix:
    name: Build Hotfix Image
    runs-on: ubuntu-latest
    needs: [validate-hotfix, quick-tests]
    if: always() && (needs.quick-tests.result == 'success' || needs.quick-tests.result == 'skipped')
    permissions:
      contents: read
      packages: write
    
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=raw,value=hotfix-${{ needs.validate-hotfix.outputs.hotfix-version }}
          type=sha,prefix=hotfix-
          
    - name: Build and push hotfix image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  deploy-hotfix-staging:
    name: Deploy Hotfix to Staging
    runs-on: ubuntu-latest
    needs: [validate-hotfix, build-hotfix, emergency-approval]
    if: always() && needs.build-hotfix.result == 'success' && (needs.emergency-approval.result == 'success' || needs.emergency-approval.result == 'skipped')
    environment:
      name: staging
      url: https://staging.python-service.com
    
    steps:
    - name: Deploy to staging
      run: |
        echo "ðŸš€ Deploying hotfix to staging..."
        echo "Image: ${{ needs.build-hotfix.outputs.image-tag }}"
        echo "Version: ${{ needs.validate-hotfix.outputs.hotfix-version }}"
        # Add your staging deployment logic here
        
    - name: Run smoke tests
      run: |
        echo "ðŸ§ª Running smoke tests..."
        sleep 30  # Wait for deployment
        # curl -f https://staging.python-service.com/health
        
    - name: Validate hotfix
      run: |
        echo "âœ… Hotfix deployed and validated on staging"

  deploy-hotfix-production:
    name: Deploy Hotfix to Production
    runs-on: ubuntu-latest
    needs: [validate-hotfix, build-hotfix, deploy-hotfix-staging]
    if: success() && (github.event.inputs.target_environment == 'production' || github.ref_name == 'hotfix/production')
    environment:
      name: production
      url: https://python-service.com
    
    steps:
    - name: Pre-deployment checklist
      run: |
        echo "ðŸ“‹ Pre-deployment checklist:"
        echo "âœ… Hotfix validated on staging"
        echo "âœ… Emergency approval received (if required)"
        echo "âœ… Docker image built and scanned"
        echo "â³ Ready for production deployment"
        
    - name: Deploy to production
      run: |
        echo "ðŸš€ Deploying hotfix to production..."
        echo "Image: ${{ needs.build-hotfix.outputs.image-tag }}"
        echo "Version: ${{ needs.validate-hotfix.outputs.hotfix-version }}"
        # Add your production deployment logic here
        
    - name: Run production smoke tests
      run: |
        echo "ðŸ§ª Running production smoke tests..."
        sleep 30  # Wait for deployment
        # curl -f https://python-service.com/health
        
    - name: Create hotfix release
      uses: actions/github-script@v6
      with:
        script: |
          const version = '${{ needs.validate-hotfix.outputs.hotfix-version }}';
          const branchName = context.ref.replace('refs/heads/', '');
          
          // Create a tag for the hotfix
          await github.rest.git.createRef({
            owner: context.repo.owner,
            repo: context.repo.repo,
            ref: `refs/tags/v${version}`,
            sha: context.sha
          });
          
          // Create a release
          await github.rest.repos.createRelease({
            owner: context.repo.owner,
            repo: context.repo.repo,
            tag_name: `v${version}`,
            name: `Hotfix v${version}`,
            body: `## Hotfix Release v${version}
            
            This is an emergency hotfix deployment from branch \`${branchName}\`.
            
            ### Changes
            - Emergency fixes applied
            - Immediate production deployment
            
            ### Deployment
            - **Environment**: Production
            - **Image**: ${{ needs.build-hotfix.outputs.image-tag }}
            - **Commit**: ${context.sha}
            
            **âš ï¸ This is a hotfix release - please review changes carefully**`,
            prerelease: false
          });

  post-deployment:
    name: Post-Deployment Tasks
    runs-on: ubuntu-latest
    needs: [validate-hotfix, deploy-hotfix-production]
    if: always() && needs.deploy-hotfix-production.result == 'success'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Merge hotfix back to main
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        # Switch to main branch
        git fetch origin main
        git checkout main
        
        # Merge hotfix branch
        HOTFIX_BRANCH=${GITHUB_REF#refs/heads/}
        git merge origin/$HOTFIX_BRANCH --no-ff -m "Merge hotfix: $HOTFIX_BRANCH"
        
        # Push changes
        git push origin main
        
    - name: Create post-deployment issue
      uses: actions/github-script@v6
      with:
        script: |
          const version = '${{ needs.validate-hotfix.outputs.hotfix-version }}';
          const branchName = context.ref.replace('refs/heads/', '');
          
          await github.rest.issues.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            title: `Post-Hotfix Review: v${version}`,
            body: `## Post-Hotfix Review Checklist
            
            A hotfix (v${version}) has been deployed to production. Please complete the following review:
            
            ### Technical Review
            - [ ] Monitor application metrics for anomalies
            - [ ] Check error logs for new issues
            - [ ] Verify the fix addresses the original issue
            - [ ] Review performance impact
            
            ### Process Review
            - [ ] Document lessons learned
            - [ ] Update runbooks if necessary
            - [ ] Schedule post-mortem if required
            - [ ] Consider additional tests to prevent similar issues
            
            ### Follow-up Actions
            - [ ] Plan proper fix for next regular release
            - [ ] Update documentation
            - [ ] Communicate with stakeholders
            
            **Hotfix Details:**
            - Branch: \`${branchName}\`
            - Version: \`v${version}\`
            - Deployment: ${new Date().toISOString()}
            
            **Auto-created by hotfix workflow**`,
            labels: ['hotfix', 'post-deployment', 'review-required']
          });
        
    - name: Notify stakeholders
      run: |
        echo "ðŸ“¢ Notifying stakeholders of hotfix deployment..."
        echo "Hotfix v${{ needs.validate-hotfix.outputs.hotfix-version }} deployed successfully"
        # Add notification logic (Slack, email, etc.)

  rollback-plan:
    name: Prepare Rollback Plan
    runs-on: ubuntu-latest
    needs: [validate-hotfix, deploy-hotfix-production]
    if: always() && needs.deploy-hotfix-production.result == 'success'
    
    steps:
    - name: Document rollback procedure
      uses: actions/github-script@v6
      with:
        script: |
          const version = '${{ needs.validate-hotfix.outputs.hotfix-version }}';
          
          // Get previous version for rollback
          const { data: releases } = await github.rest.repos.listReleases({
            owner: context.repo.owner,
            repo: context.repo.repo,
            per_page: 2
          });
          
          const previousVersion = releases.length > 1 ? releases[1].tag_name : 'unknown';
          
          const rollbackPlan = `# Rollback Plan for Hotfix v${version}
          
          ## Quick Rollback Commands
          \`\`\`bash
          # Rollback to previous version: ${previousVersion}
          # kubectl set image deployment/python-service python-service=ghcr.io/${{ github.repository }}:${previousVersion}
          # docker service update --image ghcr.io/${{ github.repository }}:${previousVersion} python-service
          \`\`\`
          
          ## Rollback Checklist
          1. [ ] Stop current deployment
          2. [ ] Deploy previous stable version
          3. [ ] Verify application health
          4. [ ] Check database compatibility
          5. [ ] Monitor for errors
          6. [ ] Notify team of rollback
          
          ## Previous Stable Version
          - Version: ${previousVersion}
          - Image: ghcr.io/${{ github.repository }}:${previousVersion}
          
          Generated: ${new Date().toISOString()}`;
          
          console.log('Rollback plan prepared:');
          console.log(rollbackPlan);
